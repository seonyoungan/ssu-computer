## 1. 영상의 필터링
#### 1. 필터링
  1. 영상의 원하는 정보만 통과, 나머지는 걸러내는 작업(=like 체)  
  2. 영상 필터링은 보통 마스크라고 부르는 작은 크기의 행렬 이용  

#### 2. 마스크 (= 커널, 윈도우)
  1. 필터링의 성격을 정의하는 원소가 실수로 구성된 행렬  
  2. 다양한 크기와 모양으로 정의 가능  

#### 3. 필터링 연산 방법
  1. 직사각형 행렬: 1x3, 5x1  
  2. 정사각형 행렬: **3x3**, 5x5  

#### 4. 필터링 연산 방법
  1. 대부분 마스크 행렬 정중앙을 고정점(anchor point) 사용(=기준 픽셀)  
  2. 연살 결과는 마스크 해열ㄹ의 모양과 원소 값에 의해 결정  
  3. 마스크를 이용한 필터링 :  마스크 + 입력영상 = 출력영상  
  4. 가장자리 픽셀 처리 (정리 필요)  
  5. `filter2D()` 함수를 통해 필터링 수행  
    * 인자로 `ddepth`를 사용해 영상의 깊이를 지정함  
    * ddepath 기본값은 0이고 ddepath에 -1을 지정하면 출력영상의 깊이 = 입력영상의 깊이   
  6. 수식: $dst(x,y) = \sum_{j}\sum_{i}kernel(i,j)·src(x+i-anchor.x,y+j-anchor.y)+delta$  
  
#### 5. 엠보싱 필터링
  1. 엠보싱 필터: 입력영상을 엠보싱 느낌이 나도록 변환  
    * 보통 입력영상에서 픽셀값 변화가 적은 평탕한 영역은 회색으로 설정  
    * 객체의 격계부분은 밝거나 어둡게 설정하면 엠보싱   

|-1|-1| 0|
|--|--|--|
|-1| 0| 1|
| 0| 1| 1|
  2. 엠보싱 필터를 구현할 때 결과영상에 128을 더해야 하는 이유  
    * 대각선방향으로 픽셀값이 급변하는 영역→ 결과 영상의 픽셀값이 0보다 훨씬 크거나 훨씬 작은 값을 가짐  
    * 입력영상에서는 픽셀값이 평탄한 영역→ 결과영상에서 픽셀값이 0에 가까운 값을 가짐  
    * 이렇게 구현한 영상이 그대로 화면에 나타나면 음수값은 포화연산에 의해 0이 되어 입체감이 크게 줄기 때문에 128을 더하는 게 좋음  
```py
...
emboss = np.array[[-1,-1,0],
                  [-1,0,1],
                  [0,1,1]], np,float32)
dst = cv.filter2D(src, -1, emboss, delta=128) #128 더하기
cv.imshow('dst', dst)
```

## 2. 블러링 (=스무딩 기법)
### 1. 사용이유
  1. 인접 픽셀 간의 픽셀 값 변화가 크지 않으면 부드러운 느낌을 줌  
  2. 거친 느낌을 부드럽게 만들거나 입력영상의 잡음의 영향을 제거하는 전처리 과정으로 쓰기도 함  
  
### 2. 종류
#### 1. 평균값 필터 (산술 평균)
  1. 개념: 입력영상의 특정 픽셀과 주변 픽셀의 산술 평균을 결과 영상의 픽셀값으로 설정하는 필터  
  2. 장점: 날카로운 에지가 무뎌지고 잡음의 영향을 크게 사라지게 함  
  3. 단점: 과도하면 사물의 경계가 흐릿해지고 사물의 구분이 어려워짐  
  4. 특징  
      * 마스크의 크기(행렬) 크기가 커질 수록 더욱 부드러운 영상을 생성함. 대신 연산량이 크게 증가함  
      * 각각의 행렬은 모두 원소값을 1로 설정하고, 행렬의 전체 원소 개수로 각 행렬 원소값을 나누는 형태로 표현 = $\frac {1}{행렬의 전체 원소 개수}$  
  5. blur()함수를 이용해 평균값 필터링 수행  

#### 2. 가우시안 필터 (가중 평균)
  1. 개념: 평균을 중심으로 좌우대칭의 종모양을 갖는 확률분포(=정규분포)를 말함  
      * 자연계에서 발생하는 대부분의 사건은 가우시안 분포에 따름  
      * `평균`과 `표준편차`에 따라 분포 모양 결정하나, 영상의 가우시안 필터는 주로 `평균이 0`인 가우시안 분포함수 사용  
  2. 수식1 : 평균(=중심값)이 0이고 표준편차(=얼마나 뾰족한지)가 $\sigma$인 1차원 가우시안 분포의 함수식 
      * $G_\sigma (x) = \frac{1}{\sqrt{2𝝿\sigma}}e^\frac{x^2}{2\sigma^2}$   
        * 세개의 그래프 모두 평균이 0이므로 x=0에서 최대값임  
            * 표준편차 $\sigma$가 작으면 그래프가 뾰족함  
            * 표준편차 $\sigma$가 크면 그래프가 완만함  
        * 특정x가 발생할 수 있는 확률 = 가우시안 분포값 함수    
            * ∴ 그래프의 아래 면적을 모두 더하면(=모든 상황을 다 합치면) 1이됨  
  3. 수식2 : 평균이 (0.0)이고 x축과 y축 방향의 표ㅗ준편차가 각각 $\sigma_x$, $\sigma_y$인 2차원 가우시안 분포함수  
      * $G_{\sigma_x \sigma_y}(x,y) = \frac{1}{\sqrt{2𝝿\sigma}}e^{(\frac{x^2}{2\sigma_x^2}+\frac{y^2}{2\sigma_y^2})}$  
        * 1차원과 성질 동일함(함수 그래프 아래부분의 부피를 구하면 1!)
        * 평균이(0,0)이므로 그래프는 (0,0)에서 최댓값 찾고, 평균에서 멀어질 수록 함수 감소  
        * 가우시안 함수는 연속함수 이지만 이산형의 마스크를 만들기 위해 x,y갑싱 정수인 위치에서만 가우시안 분포 함수값 추출해 마스크 생성  
        * 보통 (8+$\sigma$+1)로 결정  
  4. 가우시안 필터의 특징  
      * 마스크 크기가 커지면 연산량도 함께 증가  
      * 그러나 다행히 2차원 가우시안분포함수는 1차원 가우시안 분포 함수 곱으로 분리할 수 있어 연산량 크게 줄일 수 있음  
      * 2차원 가우시안 분포함수의 $e^{(\frac{x^2}{2\sigma_x^2}+\frac{y^2}{2\sigma_y^2})}$ 부분을 쪼개면 결국 $G_{\sigma(x)}(x)·G_{\sigma(y)}(y)$  
  5. `GaussianBlur()`함수로 가우시안 필터링 수행 가능  
  6. `getGaussianKernel()`함수는 1차원 가우시안 필터 마스크를 생성할 때 사용  
      * ksize는 (8*sigma+!)보다 같거나 크게 지정하는 것이 좋으므로, 저장되는 값은 아래 수식을 따름  
        * $G_i = α·e^{-\frac{(i-(ksize-1)/2)^2}{2·sigma^2}}$  

## 3. 샤프닝
### 1. 언샤프 마스크 필터 : 경계선 부분 차이 크게 해야 날카로운 느낌이 난다.  
      1. 에지 근방에서 픽셀값의 명암비가 커지도록 수정하면 초점 잘 맞아 보임  
      2. 블러링된 영상(언샤프드)을 사용해야 샤프닝 효과를 낼 수 있음  
### 2. $h(x,y) = f(x,y)+α·g(x,y)$  
      1. 최종영상 h(x,y) = 입력영상f(x,y) + 얼마나 날카롭게할지(α) * 날카로운 성분이 강조된g(x,y)  
      2. α = 1.0 하면 날카로운 성분을 그대로 한번 더 곱하는 것이고, α < 1.0이면 조금 덜 날카로운 영상을 만듦  
### 3. openCV에서는 언샤프 마스크 필터 함수를 제공하지 않음  
      1. 표준편차 값으로 가우시안 필터 적용, 블러링된 영상을 이용해 샤프닝 결과 생성  
```py
...
for sigma in range(1,6): #시그마를 1~5까지 사용
  blurred = cv.GaussianBlur(src, (0, 0), sigma) # 커널의 사이즈는 시그마로부터 결정되도록하고, 블러링된 영상을 가져옴
  
  alpha = 1.0 #알파값은 1.0으로 하여 날카로운 성분을 그대로..?
  dst = cv2.addWeighted(src, 1+alpha, blurred, -alpha, 0.0) # 두개의 합이 1이되도록 addWeighed를 함(소스영상에 1+alpha, 블러링된 영상에 -alpha해준 것)
...
```

### 4. 커널을 활용하는 방법

| 0|-1| 0|
|--|--|--|
|-1| 5|-1|
| 0|-1| 0|

  1. 특징  
    * 상하 좌우 값을 줄이고 가운데를 크게 함.  
    * weight는 5-4해서 1이므로 평균 밝기가 그대로 유지된다.  
    * 값을 어떤 것을 넣느냐에 따라 달라짐 (형태를.. 알아두자)  


## 4. 잡음 제거 필터링
### 1. 영상과 잡음 모델
  1. 수식: $f(x,y) = s(x,y) + n(x,y)$  
     * 출력영상 = 입력영상 + 추가잡음  
      * 가우시안 잡음 모델이 대표적임 (보통 평균이 0인 가우시안 분포를 따르는 잡음)  
      * `randn()` 함수 사용  
          * 난수가 발생할 수 있으므로 CV_32S, CV32F 등 부호있는 자료형 행렬 사용해야 함  
          * 노이즈는 양수, 음수 줄 수 있고! 회색조는 0~255(unsigned)  
```py
...
for stddev in [10,20,30]:
  noise = np.zeros(src.shape, np.int32) # 0으로 채움
  cv.randn(noise, 0, stddev) #표준 편차로 생성. 

dst = cv.add(src, nose, dtype=cv.CV_8UC1)
...
```
      * 표준편차가 커지면 커질수록 노이즈가 많이 생김  
      * 활용: 딥러닝은 빅데이터가 필요하므로, 이미지를 여러 형태로 이미지 셋 펌핑하는 데에 사용  

### 2. 양방향 필터
  1. 대부분의 영상은 **가우시안잡음**이 포함되어있고, 이것을 제거하기 위해 가우시안 필터 사용  
  2. 평탄한 영역에 가우시안 필터가 적용될 경우, 주변 픽셀 값이 부드럽게 블러링 되어 잡음 영향 크게 줄어듦  
  3. 픽셀 값이 급격하게 변경되는 에지근방에 동일한 가우시안 필터가 적용되면 잡음뿐만 아니라 에지 성분까지 함께 감소  
  4. 이 단점을 보완하기 위해 많은 사람들이 에지정보는 그대로 유지하면서 잡음만 제거하는 **에지 보전 잡음 제거 필터** 연구  
  5. $g_p = \frac{1}{W_p} \sum_{q∈S} G_{\sigma_s} (||p-q||)G_{\sigma_r} (|f_p - f_q |)f_q$  
      * 어느위치에 어떤 앵커포인터에구하게 되냐에 따라서 곱해지는 커널 함수가 다 달라진다.  
  6. 장점:  
      원래의 가우시안: 거리가지고 처리를 했음.    
      그러나 양방향 필터는 거리(위치)와 밝기 차를 사용한다.  
      밝기 차는 나와 픽셀값이 비슷하면 가중치를 크게주고, 차이가 많이나면 가중치를 작게 줌  
      차이 값이 크면 가중치를 낮춰줌으로써 블러링되는 강도를 낮춰준다. (=엣지 보정을 위함)  
  7. 단점: 가우시안 블러링보다 훨씬 많은 연산량을 필요로 한다.
  8. `bilateralFilter()`를 사용해 양방향 필터 수행함
```py
...
dst1 = cv.GaussianBluer(src, (0,0), 5) #가우시안 블러링 (얼룩덜룩한 게 평평한 영역에서 보임)
dst2 = cv.bilateralFilter(src, -1, 10, 5) #양방향 필터링 (엣지가 보존됨)
```

### 3. 미디언 필터(=소금, 후추 잡음)
  1. 입력영상에서 자기 자신 픽셀, 주변 픽셀값 중 중간 값 선택하는 필터링 기법
  2. 특징
      * 마스크 행렬과 입력영상 픽셀 값을 서로 곱하고 더하는 형태의 연산 사용하지 않음
      * 차이점: 주변 픽셀 값들의 중간 값을 선택하기 위해 내부에서 픽셀 값 정렬 과정이 사용됨
      * 효과: 잡음 픽셀값이 주변 픽셀값과 큰 차이가 있을 때
  3. `medianBlur()` 함수를 이용해 미디언 필터링 수행
      * filter_median()함수는 입력영상 전체 크기의 10%에 해당하는 픽셀에 median 잡음을 추가
      * 소트&패턴노이즈 적용 -> 노이즈 날아감 -> 노이즈 제거

